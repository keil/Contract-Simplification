OPEN POINTS
===========

- @ with blame lable
- multiple arguments

- Test Grammar
- Cleanup


Next Steps & Open Problems
==========================

*** DO WE REALLY NEED THE SYMBOLIC EXECUTER ?

In sum, I do not believe that the SE is really needed. At the moment I do not
have a good example that requires the SE. Assuming we use the full optimizer
(this also includes the non-blame-preserving optimization steps) than all
unchecked contracts are propagated along the execution path. A subset relation
(which finally needs to follow the same rules than the SE) can combine
contracts.

In case that we do not use the non-blame-preserving steps, reducing contracts
based on accumulated knowledge seems to be useful as contracts cannot be lifted. 

*** LEVELS of DIFFERENT GUARANTEES

Enable/Disable certain rules to switch between different optimisation steps and guarantees.

*** BLAME-PRESERVING
Whenever a contract assertion (M @ b C) is deconstructed or moved, the initial blame label remains (M @ b) such that in case of a blame error (blame b) the initial position (M @ b) reduces to (blame b): (M @ b) â€”> (blame b)
This should be instead of throwing/reducing to a global static blame as it is done in the dynamics. The preceding SE can than give static blame messages ion there is a flow between.


*** BLAME-PRESERVATION

Unfortunately, non of the rules is really blame preserving. 
Consider:
let f = ( \x . (* 1@^1 Str x@^2 Str) @^3 Str ) 

The dynamic execution of (f true) would reduce to (+blame 1), because  1@^1 Str
is the first lifted contract.

After plain optimization, the execution of (f true) would reduce to (+blame 2),
because it would lift x@^2 Str to (( \x . (* 1@^1 Str x) @^3 Str ) @^2 Str->T )

SE on the other hand would reduce to a static blame because the signature of *
is *: Num -> .. -> Num








*** Levels

i) Symbolic Executer/ Symbolic Refinement

- Not clear if the symbolic executer needs to run first or last. Clearly, we
  loose contracts (and information) during the optimization. Is there an
  intersection between contracts that will be optimized and contracts
  refined based on symbolic informations. E.g. symbolic refinement refines the
  output and focuses on predicates whereas optimization considers input and
  delayed contracts.

- How to related the outcome of the Symbolic Executer with the current program.
  (Calculus/ Rules required)

ii) Pre-Evaluator

iii) Contract Propagation


*** Open Points

- Definition of contract subset (especially for predicates)
  a) How to define predicates.
  b) Subset relation

- Static Blame

  What should happen if we detect an errors, e.g. a contract that definitely
  fails. Throwing an error would change the blame-order.

- Lift and Function Boundaries

  a) Lifting changes the order of checked contracts, e.g. \x. (+ y@Num, x@Num)
  b) Lifting over function boundaries may check contracts which otherwise would
  never be checked, e.g. because an inner function is never called.

  Thus, lifting is not blame-preserving.
  
  We need a valid definition/use case for this situation.
  



Example:

( \plus.E[[ (\z.((plus z) 1)) @ (Num -> Num) ]] ) ((\x.\y.(+ x y)) @ Num -> (Num
-> Num) \cap Str -> (Str -> Str))

-->*

( \plus.E[[ (\z.((plus z) 1)) @ (Num -> Num) ]] ) (\x.\y.(+ x y))









Open Points
===========

*** Make own test function that previously checks the syntax.

*** Predefined Contracts

*** Implement Setminus
*** Naive Subtyping/ Subset/ Collapse


static blame
- reduction of (\top -> C) to only C

Bugfix \sumOf


*** Theorems
- Simulation
- Progress/ Preservation
- Blame



- Questions

- A possibility to simplify examples
- e.g. by using the Names ,Nat instead of the predicate?
- use preducate names and unroll only when needed.


- how can I guarantee that I do not create more contract, for example 
- because some value is not used




- normale code optimization required,
- this means 
etwa reduction
\X.X -> X


- implement a native if because if is an interesting case
- similat ro rackets native case ?


Predicate Refinement
====================

- Implement a predicate refinement similar to the fullback in TreatJS.

i) State different properties independently from other properties and let the
   final flat-contract be a conjunction of different predicates. 
   (flat M ...)

ii) Each predicates is a refinement of other predicates.
    (flat \ x (number? x)) refined \top

iii) Implement subset calculation and set difference.





Lower
-----

- One can say that immediate contracts should not be lowered but lowering them
  enables to optimize them on an upper level




Untoll
------

- Make an example where range/domain contract are itself a function contract.
  What shoudl be the intednded result?


 
Collapse
--------

- Implement Meta-Function



Native contracts
----------------

Implement predefined contracts for native operators! 
(Should they raise a static blame iif they know that the dynamic execution woult
fails?)

- in combination with refinement predicates
- a contract on the output of a native function





Subject-free/ pre-evaluated contracts
-------------------------------------

Immediate contracts on the range gets moved into the fun runs body?

- Only non-checkable delayed contracts remain.

But, is it than possible to produce an upper-level interface description?
Benefits?

- Compare to norms unrolling 

Normalized Contract:
(Intersection/ Union/ Dependent Contract/ Abstraction)

Contract C:= D -> R 

Domain D := I | R -> D
Range R := T | D -> R

Example:
(N -> N) -> (N -> N)
(T -> N) -> (N -> T)

Efficient reduction vs. an upper description (contract).
(Context contract, alternative is to split the contract, similar to Dimulas and
than to assert both parties in separation?)



Collapse Predicates
===================

- needs to preserve the order of the checked predicates
- (reverse the order when combining function contracts)




Contract Integration
====================

*** Approaches
i) first to define a contract subset of remaining contracts
ii) use a split operator to produce two (subject/context) contracts

- \ x . 1 @ Num -> Num
  is not allowed to be reduced to \ x . 1 
  because \ x . 1 can be called with values other than Num

- \ x . x @ Num -> Num
  is not allowed to be reduced to (\ x . (x @ Num)) @ (Num - T)
  because the constraint for (x @ Num) is created once ans all evaluations 
  will update to the same constraint


=> This, we are only allowed to replace \ x M @ Q to all uses but not con
concentrate a number of applications on one assertion

=> one delayed assertion --> multiple assertion on all uses

It remains, is it possible to make an common evaluation, with a neutral context
to detect definitive static blame messages.



Questions
=========

*** Will moving contracts cause more contract violations, as some violations
might not happen because a function is never called?

