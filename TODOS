\Con
====

- Implement blame semantics/ callbacks
- Implement Intersection and Union Contracts
- (Implement Contract Abstraction/ Dependent Contract)


Open Points
===========

*** Theorems
- Simulation
- Progress/ Preservation
- Blame



- Questions

- A possibility to simplify examples
- e.g. by using the Names ,Nat instead of the predicate?
- use preducate names and unroll only when needed.


- how can I guarantee that I do not create more contract, for example 
- because some value is not used




- normale code optimization required,
- this means 
etwa reduction
\X.X -> X


- implement a native if because if is an interesting case
- similat ro rackets native case ?


Predicate Refinement
====================

- Implement a predicate refinement similar to the fullback in TreatJS.

i) State different properties independently from other properties and let the
   final flat-contract be a conjunction of different predicates. 
   (flat M ...)

ii) Each predicates is a refinement of other predicates.
    (flat \ x (number? x)) refined \top

iii) Implement subset calculation and set difference.







Untoll
------

- Make an example where range/domain contract are itself a function contract.
  What shoudl be the intednded result?


 
Collapse
--------

- Implement Meta-Function



Native contracts
----------------

Implement predefined contracts for native operators! 
(Should they raise a static blame iif they know that the dynamic execution woult
fails?)

- in combination with refinement predicates
- a contract on the output of a native function





Subject-free/ pre-evaluated contracts
-------------------------------------

Immediate contracts on the range gets moved into the fun runs body?

- Only non-checkable delayed contracts remain.

But, is it than possible to produce an upper-level interface description?
Benefits?

- Compare to norms unrolling 

Normalized Contract:
(Intersection/ Union/ Dependent Contract/ Abstraction)

Contract C:= D -> R 

Domain D := I | R -> D
Range R := T | D -> R

Example:
(N -> N) -> (N -> N)
(T -> N) -> (N -> T)

Efficient reduction vs. an upper description (contract).
(Context contract, alternative is to split the contract, similar to Dimulas and
than to assert both parties in separation?)
