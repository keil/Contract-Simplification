\Con
====

- Implement blame semantics/ callbacks
- Implement Intersection and Union Contracts
- (Implement Contract Abstraction/ Dependent Contract)


Open Points
===========

*** Theorems
- Simulation
- Progress/ Preservation
- Blame



- Questions

- A possibility to simplify examples
- e.g. by using the Names ,Nat instead of the predicate?
- use preducate names and unroll only when needed.


- how can I guarantee that I do not create more contract, for example 
- because some value is not used




- normale code optimization required,
- this means 
etwa reduction
\X.X -> X


- implement a native if because if is an interesting case
- similat ro rackets native case ?


Predicate Refinement
====================

- Implement a predicate refinement similar to the fullback in TreatJS.

i) State different properties independently from other properties and let the
   final flat-contract be a conjunction of different predicates. 
   (flat M ...)

ii) Each predicates is a refinement of other predicates.
    (flat \ x (number? x)) refined \top

iii) Implement subset calculation and set difference.







Untoll
------

- Make an example where range/domain contract are itself a function contract.
  What shoudl be the intednded result?


 
Collapse
--------

- Implement Meta-Function
