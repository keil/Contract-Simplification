Open Points
===========

*** Make own test function that previously checks the syntax.

*** Predefined Contracts

*** Implement Setminus
*** Naive Subtyping/ Subset/ Collapse






*** Theorems
- Simulation
- Progress/ Preservation
- Blame



- Questions

- A possibility to simplify examples
- e.g. by using the Names ,Nat instead of the predicate?
- use preducate names and unroll only when needed.


- how can I guarantee that I do not create more contract, for example 
- because some value is not used




- normale code optimization required,
- this means 
etwa reduction
\X.X -> X


- implement a native if because if is an interesting case
- similat ro rackets native case ?


Predicate Refinement
====================

- Implement a predicate refinement similar to the fullback in TreatJS.

i) State different properties independently from other properties and let the
   final flat-contract be a conjunction of different predicates. 
   (flat M ...)

ii) Each predicates is a refinement of other predicates.
    (flat \ x (number? x)) refined \top

iii) Implement subset calculation and set difference.





Lower
-----

- One can say that immediate contracts should not be lowered but lowering them
  enables to optimize them on an upper level




Untoll
------

- Make an example where range/domain contract are itself a function contract.
  What shoudl be the intednded result?


 
Collapse
--------

- Implement Meta-Function



Native contracts
----------------

Implement predefined contracts for native operators! 
(Should they raise a static blame iif they know that the dynamic execution woult
fails?)

- in combination with refinement predicates
- a contract on the output of a native function





Subject-free/ pre-evaluated contracts
-------------------------------------

Immediate contracts on the range gets moved into the fun runs body?

- Only non-checkable delayed contracts remain.

But, is it than possible to produce an upper-level interface description?
Benefits?

- Compare to norms unrolling 

Normalized Contract:
(Intersection/ Union/ Dependent Contract/ Abstraction)

Contract C:= D -> R 

Domain D := I | R -> D
Range R := T | D -> R

Example:
(N -> N) -> (N -> N)
(T -> N) -> (N -> T)

Efficient reduction vs. an upper description (contract).
(Context contract, alternative is to split the contract, similar to Dimulas and
than to assert both parties in separation?)



Collapse Predicates
===================

- needs to preserve the order of the checked predicates
- (reverse the order when combining function contracts)




Contract Integration
====================

*** Approaches
i) first to define a contract subset of remaining contracts
ii) use a split operator to produce two (subject/context) contracts

- \ x . 1 @ Num -> Num
  is not allowed to be reduced to \ x . 1 
  because \ x . 1 can be called with values other than Num

- \ x . x @ Num -> Num
  is not allowed to be reduced to (\ x . (x @ Num)) @ (Num - T)
  because the constraint for (x @ Num) is created once ans all evaluations 
  will update to the same constraint


=> This, we are only allowed to replace \ x M @ Q to all uses but not con
concentrate a number of applications on one assertion

=> one delayed assertion --> multiple assertion on all uses

It remains, is it possible to make an common evaluation, with a neutral context
to detect definitive static blame messages.



Questions
=========

*** Will moving contracts cause more contract violations, as some violations
might not happen because a function is never called?

