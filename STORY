


Predicates
==========

- Unrolling/Combining predicates works only if predicates are pure. This means
  that base contracts and abstractions cannot be refined or reduces as there
  evaluation may depend on the current context. 
  
  New flat contracts/ predicates are stateless and have to work on their input.
  Further, the argument is wrapped in a special proxy that projects objects and
  guarantees that the predicate did not access the object. This is required
  because the object may change over time. And checking a predicate on an object
  twice may not lead to the same outcome, as the object changes over time and
  also because a property access in a predicate may change the object itself. 
  
  All other kinds need to implemented as another/special contract, e.g. Method
  Contract or Invariant Contract.




Baseline Optimization
=====================

Lift 
----

- Needs to stop at the first lambda term, as this lambda might never be called.
  This step guarantees that we do only "benefiting" optimizations.

- It is only allowed to lift immediate contract because delayed contract will be
  checked later on (or never) and it is not possible to combine them.

  => Delayed contract on function a valid final terms (even if they are nested
  in a subexpression)


Unroll
------

- We unroll the function/ delayed contract to all uses of that function. 

  We do not split domain/range contract at this place and we neither move the
  domain contract to the applications mot do we move the range contract to the
  function body.

  The reason for is as follows:

  i) A delayed contract may also be an intersection, and thus it would require
  to the unroll the whole contract at definition.
  
  ii) The goal is to create a contract on the upper/enclosing function, and
  moving the range contract to the function body prohibits this.

  iii) What happens is domain/range contract are itself function contracts?



Lower
-----

- It would be ok to lower only delayed contracts


General Notes
=============

- Two different delayed contracts on a value cannot be combined to an
  intersection, as the intersection provides a different semantics
  -- the domains might not be disjount, this, a wront party might be blamed.



Symbolic Execution
==================

; only alloweed to collect predicates that evaluate to true ?
; reasong is that we need to consider the blame, od checked predictae
; collecting did not mean that the value satisfied the contract/ only that it is checked against this contract
; but without a check of th blame state this is useless

Consider the reduction of:
(term ((¿ x ((if (boolean? x) (¿ x (or x 1)) (¿ x (+ x 1))) x)) (? / (¿))))
The result could be Bool \vee Num
;; better to say if fullfilles Bool? or Num?
;; which is another predicate




Predicate Refinements
=====================

- How to knwo taht X>0 is subset of X>=0
- Or that real? ist subset of number?

*** Problem: 
- Manual assignment might be wrong. So, where to know that the rule is correct?
- The second contract/predicate might not be available when creating the first
  one. So, there is no valid subset information.. 
