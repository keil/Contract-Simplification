*** Predicate Optimization

Baseline Optimization
=====================

Reduces Flat Contracts
----------------------

Reduces all flat contracts that can be checked at compile time. In particular
this are all:

i) c @ (flat e) 
ii) \ x e @ (flat e)

Only c @ (flat e) expressions remain.

Reduce Function Contracts
-------------------------

Reduces all function contracts on non-function objects.

c @ (C -> D)

Only function contracts on function (contracted functions) remain.



Base/Native Operations
----------------------

- Use hard coded contracts to wrap native operations
- and use the contact version instead of the original one.

- Thus, instead of using plus (+), we can use + @ Num,Num->Num
- The contract should be as precises as possible.
- We than can check the input/ and use the range contract for lifting


Notes
=====

- unfold/unroll are "blame preserving" rules
- the do only the those operation which would otherwise be done at runtime.

- lift is also "blame preserving" as it does only earlier checking of the
- contract, and because the rules preserve the order of the checked contract
- it did not change the semantics

- Only, collapse needs to give a special consideration to blame preservation.

- Use: 
-- flatten (alternative to unfold/ or to unroll an intersectiopn)
-- plasticize (to create new function contracts)





Blame Preservation
==================

Optimizing contract needs to preserve the blame behaviour of a program. This
requires:

i) Contracts must be checked in the same order, i.e. updating the callback
structure (constrains) must happen in the same order as the dynamic checking
would update the constraint state.

ii) Only immediate contract on variables can be lifted. This is required as a
variable can be checked against two different contracts in two different
context, whose domain is not disjoint.

iii) A contract in the body of another closure is not allowed to be lifted, as
the function might not be called. In this situation we can maybe introduce a new
function/ application to create a new function contract.


Static Blame
============

What to do if an expression evaluates statically to blame?

As the function body might not be called, we are not allowed to evaluate
completely to blame.














- Lifting only x@I of x is direclty used in the body
- otherwise introduce a new lambda term

\x \y (+ x@I y)

- x@I cannot be lifted to \x because \y M might never be used/called

   \x \y (+ x@I y)
~> \x \y (\x (+ x y) @ I->*) (x)




- eta reduction
