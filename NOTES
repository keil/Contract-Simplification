Baseline Reduction
==================

Guarantees
- Real-Optimization
- Order-Preservation (includes Blame-Preservation)

- optimize of


Subset Reduction
================

Guarantees
- Real-Optimization
- Blame-Preservation


Optimize dependent contracts

what if also in baseline perps must nor remain at the current locatioin, but can be moved.





*** Constrains

- Is it really required to produce true-contrasts? I assume that a blank constraint set is enough. 


*** Predicate Optimization

- user has to define a predicate subset before runnting the optimizer,
as for TraceTyping


Baseline Optimization
=====================

Reduces Flat Contracts
----------------------

Reduces all flat contracts that can be checked at compile time. In particular
this are all:

i) c @ (flat e) 
ii) \ x e @ (flat e)

Only c @ (flat e) expressions remain.

Reduce Function Contracts
-------------------------

Reduces all function contracts on non-function objects.

c @ (C -> D)

Only function contracts on function (contracted functions) remain.



Base/Native Operations
----------------------

- Use hard coded contracts to wrap native operations
- and use the contact version instead of the original one.

- Thus, instead of using plus (+), we can use + @ Num,Num->Num
- The contract should be as precises as possible.
- We than can check the input/ and use the range contract for lifting


Notes
=====

- unfold/unroll are "blame preserving" rules
- the do only the those operation which would otherwise be done at runtime.

- lift is also "blame preserving" as it does only earlier checking of the
- contract, and because the rules preserve the order of the checked contract
- it did not change the semantics

- Only, collapse needs to give a special consideration to blame preservation.

- Use: 
-- flatten (alternative to unfold/ or to unroll an intersection)
-- plasticize (to create new function contracts)



Contract Propagation
====================

- Contract Propagation (swap) works only if predicates are (stateless) and
  independent from the external state. 
- This means, if a predicate uses/refers to some external values, swap may
  change the outcome of a predicate, i.e. because an operation between effects
  some external values.
- Swap is also nit allowed to change the order of predicates.
- Swap works for "pure" predicates.
- All other contract (Base, Abstraction, With) need a special treatment.

- Implement a function checking if a contract C is pure, i.e. it consists of
  base type pure predicates or arbitrary constructs of them.


Blame Preservation
==================

Optimizing contract needs to preserve the blame behaviour of a program. This
requires:

i) Contracts must be checked in the same order, i.e. updating the callback
structure (constrains) must happen in the same order as the dynamic checking
would update the constraint state.

ii) Only immediate contract on variables can be lifted. This is required as a
variable can be checked against two different contracts in two different
context, whose domain is not disjoint.

iii) A contract in the body of another closure is not allowed to be lifted, as
the function might not be called. In this situation we can maybe introduce a new
function/ application to create a new function contract.


Static Blame
============

What to do if an expression evaluates statically to blame?

As the function body might not be called, we are not allowed to evaluate
completely to blame.














- Lifting only x@I of x is direclty used in the body
- otherwise introduce a new lambda term

\x \y (+ x@I y)

- x@I cannot be lifted to \x because \y M might never be used/called

   \x \y (+ x@I y)
~> \x \y (\x (+ x y) @ I->*) (x)




- eta reduction


Inner Unfold
============

- Not possible to replace one delayed contract by one immediate check.



Abstract Values
===============

- Think about:
  Use abstract values { V | I } to remember previously evaluated predicates.

- Virtual Contract:
  Use virtual contracts for primitive operations. But only to reduce imemdiate
  Contracts, and not to lift the contract to an upper description.

- Use symbolic execution to verify contracts?



If-Condition
============

- Implement if construct
- Contract the expression with a dependent contract
- Union of two dependent contracts



Notes
=====

Static evaluation needs to produce a constraint set


Open questions
==============

*** Symbolic Contract Checking
*** Hybrid Contract Checking

How do I recognize that it is required to in-roll a contract.
Inroll with static parallel execution.

- Im only allowed to to the same thing than the standard evaluation would do
- An immediate contract on the domain would be asserted to a value, not to the
  variable., Thus, doing this would break the behaviour.

- 


*** Two delayed contract on a value/ variable are not allowed to be combined to
an intersection on the upper level, because both contract may flow into
different branches. Or, the subsequent evaluation attempts to fulfill the wrong
side of the contract.

